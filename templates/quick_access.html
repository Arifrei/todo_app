{% extends 'base.html' %}

{% block content %}
<div class="quick-access-page">
    <header class="header-row">
        <div>
            <h1>Quick Access</h1>
            <p style="color: var(--text-muted);">Your frequently accessed items</p>
        </div>
        <button class="btn btn-primary" onclick="openAddQuickAccessModal()">
            <i class="fa-solid fa-plus"></i> Add Item
        </button>
    </header>

    <div class="quick-access-grid" id="quick-access-grid">
        <!-- Today button (system item, always first) -->
        <a class="quick-access-card system-item" href="#" onclick="goToToday(event)" data-type="system">
            <div class="quick-access-icon"><i class="fa-solid fa-calendar-day"></i></div>
            <div class="quick-access-title">Today</div>
            <div class="quick-access-subtitle">Jump to today's calendar</div>
        </a>
        <!-- Tomorrow button (system item) -->
        <a class="quick-access-card system-item" href="#" onclick="goToTomorrow(event)" data-type="system">
            <div class="quick-access-icon"><i class="fa-solid fa-calendar-plus"></i></div>
            <div class="quick-access-title">Tomorrow</div>
            <div class="quick-access-subtitle">Jump to tomorrow's calendar</div>
        </a>

        <!-- User's custom items will be loaded here -->
    </div>
</div>

<button id="quick-access-done-btn" class="btn btn-primary" style="display: none; position: fixed; top: 1rem; right: 1rem; z-index: 100;">
    Done
</button>

<!-- Add Quick Access Item Modal -->
<div class="modal" id="add-quick-access-modal">
    <div class="modal-content">
        <h2 id="qa-modal-title">Add Quick Access Item</h2>
        <br>
        <div class="form-group">
            <label>Title</label>
            <input type="text" id="qa-title" class="form-control" placeholder="Enter title...">
        </div>
        <div class="form-group">
            <label>Icon (FontAwesome class)</label>
            <input type="text" id="qa-icon" class="form-control" placeholder="fa-solid fa-bookmark" value="fa-solid fa-bookmark">
            <small style="color: var(--text-muted);">Browse icons at <a href="https://fontawesome.com/icons" target="_blank">fontawesome.com/icons</a></small>
        </div>
        <div class="form-group">
            <label>Type</label>
            <select id="qa-type" class="form-control" onchange="handleQuickAccessTypeChange()">
                <option value="custom">Custom URL</option>
                <option value="list">Project/List</option>
                <option value="note">Note</option>
                <option value="calendar">Calendar Date</option>
            </select>
        </div>
        <div class="form-group" id="qa-url-group">
            <label>URL</label>
            <input type="text" id="qa-url" class="form-control" placeholder="/tasks or https://example.com">
        </div>
        <div class="form-group" id="qa-list-group" style="display: none;">
            <label>Select Project/List</label>
            <div class="qa-nav-header">
                <button class="btn btn-secondary btn-small" id="qa-back-button" style="display:none;" onclick="qaNavBack()">
                    <i class="fa-solid fa-arrow-left"></i> Back
                </button>
            </div>
            <div id="qa-list-nav-container" class="qa-nav-container">
                <!-- Navigation options populated by JS -->
            </div>
        </div>
        <div class="form-group" id="qa-note-group" style="display: none;">
            <label>Select Note</label>
            <select id="qa-note-select" class="form-control">
                <option value="">Loading...</option>
            </select>
        </div>
        <div class="form-group" id="qa-date-group" style="display: none;">
            <label>Select Date</label>
            <input type="date" id="qa-date" class="form-control">
        </div>
        <div class="modal-actions">
            <button class="btn" onclick="closeAddQuickAccessModal()">Cancel</button>
            <button class="btn btn-primary" id="qa-save-btn" onclick="saveQuickAccessItem()">Add</button>
        </div>
    </div>
</div>

<script>
const qaItemsById = new Map();
let qaEditingId = null;

// Load user's quick access items
async function loadQuickAccessItems() {
    try {
        const response = await fetch('/api/quick-access');
        const items = await response.json();
        const grid = document.getElementById('quick-access-grid');

        // Keep the system "Today" button and append custom items
        const systemCards = Array.from(grid.querySelectorAll('.system-item'));
        grid.innerHTML = '';
        systemCards.forEach(card => grid.appendChild(card));
        qaItemsById.clear();

        items.forEach(item => {
            qaItemsById.set(item.id, item);
            const card = document.createElement('a');
            card.className = 'quick-access-card';
            card.href = item.url;
            card.dataset.id = item.id;

            card.innerHTML = `
                <div class="quick-access-icon"><i class="${item.icon}"></i></div>
                <div class="quick-access-title">${escapeHtml(item.title)}</div>
                <button class="quick-access-edit" onclick="openEditQuickAccessModal(${item.id}, event)" title="Edit">
                    <i class="fa-solid fa-pen"></i>
                </button>
                <button class="quick-access-delete" onclick="deleteQuickAccessItem(${item.id}, event)" title="Delete">
                    <i class="fa-solid fa-xmark"></i>
                </button>
            `;

            grid.appendChild(card);
        });

        initQuickAccessEditMode();
    } catch (error) {
        console.error('Failed to load quick access items:', error);
    }
}

function setQuickAccessModalMode(mode) {
    const titleEl = document.getElementById('qa-modal-title');
    const saveBtn = document.getElementById('qa-save-btn');
    if (!titleEl || !saveBtn) return;
    if (mode === 'edit') {
        titleEl.textContent = 'Edit Quick Access Item';
        saveBtn.textContent = 'Save';
    } else {
        titleEl.textContent = 'Add Quick Access Item';
        saveBtn.textContent = 'Add';
    }
}

function openAddQuickAccessModal() {
    qaEditingId = null;
    setQuickAccessModalMode('add');
    document.getElementById('add-quick-access-modal').classList.add('active');
    // Reset form
    document.getElementById('qa-title').value = '';
    document.getElementById('qa-icon').value = 'fa-solid fa-bookmark';
    document.getElementById('qa-type').value = 'custom';
    document.getElementById('qa-url').value = '';
    document.getElementById('qa-date').value = '';

    resetQANavState();
    handleQuickAccessTypeChange();

    // Load lists and notes for dropdowns
    loadListsForQuickAccess();
    loadNotesForQuickAccess();
}

function closeAddQuickAccessModal() {
    document.getElementById('add-quick-access-modal').classList.remove('active');
    qaEditingId = null;
    setQuickAccessModalMode('add');
    resetQANavState();
}

// Close modal when clicking outside
document.addEventListener('click', function(e) {
    const modal = document.getElementById('add-quick-access-modal');
    if (modal && e.target === modal) {
        closeAddQuickAccessModal();
    }
});

function handleQuickAccessTypeChange() {
    const type = document.getElementById('qa-type').value;
    document.getElementById('qa-url-group').style.display = type === 'custom' ? 'block' : 'none';
    document.getElementById('qa-list-group').style.display = type === 'list' ? 'block' : 'none';
    document.getElementById('qa-note-group').style.display = type === 'note' ? 'block' : 'none';
    document.getElementById('qa-date-group').style.display = type === 'calendar' ? 'block' : 'none';
}

// Quick Access navigation state
let qaNavState = {
    currentParent: null,
    stack: [],
    allLists: [],
    selectedListId: null,
    selectedListTitle: ''
};

function resetQANavState() {
    qaNavState = {
        currentParent: null,
        stack: [],
        allLists: [],
        selectedListId: null,
        selectedListTitle: ''
    };
}

async function loadListsForQuickAccess(selectedListId = null, selectedListTitle = '') {
    try {
        const response = await fetch('/api/lists?include_children=true');
        qaNavState.allLists = await response.json();
        qaNavState.currentParent = null;
        qaNavState.stack = [];
        if (selectedListId) {
            qaNavState.selectedListId = selectedListId;
            qaNavState.selectedListTitle = selectedListTitle || '';
        }
        renderQANavigation();
    } catch (error) {
        console.error('Failed to load lists:', error);
    }
}

function renderQANavigation() {
    const container = document.getElementById('qa-list-nav-container');
    const backButton = document.getElementById('qa-back-button');

    if (!container) return;

    container.innerHTML = '';

    // Hide back button at root level
    backButton.style.display = 'none';

    // At root level, show only root-level lists (not nested children)
    // Build a set of all linked_list_ids to identify which lists are children
    const childListIds = new Set();
    qaNavState.allLists.forEach(list => {
        if (list.items) {
            list.items.forEach(item => {
                if (item.linked_list_id) {
                    childListIds.add(item.linked_list_id);
                }
            });
        }
    });

    // Filter to show only lists that are NOT children of any hub
    const itemsToShow = qaNavState.allLists.filter(list => !childListIds.has(list.id));

    if (itemsToShow.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'qa-nav-empty';
        empty.textContent = 'No projects available.';
        container.appendChild(empty);
        return;
    }

    itemsToShow.forEach(list => {
        const item = document.createElement('button');
        item.className = 'qa-nav-item';
        item.dataset.listId = list.id;

        const icon = list.type === 'hub'
            ? '<i class="fa-solid fa-folder-tree"></i>'
            : '<i class="fa-solid fa-list-check"></i>';

        const arrow = list.type === 'hub'
            ? '<i class="fa-solid fa-chevron-right"></i>'
            : '';

        item.innerHTML = `
            ${icon}
            <span>${escapeHtml(list.title)}</span>
            ${arrow}
        `;

        if (list.type === 'hub') {
            // Navigate into hub
            item.onclick = () => navigateIntoHub(list.id);
        } else {
            // Select this list
            item.onclick = () => selectQAList(list.id, list.title);
        }

        container.appendChild(item);
    });

    highlightSelectedQAList();
}

function navigateIntoHub(hubId) {
    qaNavState.stack.push(qaNavState.currentParent);
    qaNavState.currentParent = hubId;

    // Fetch hub's children
    fetch(`/api/lists/${hubId}`)
        .then(r => r.json())
        .then(hub => {
            // Update allLists to include children information
            renderQANavigationWithChildren(hub);
        })
        .catch(err => {
            console.error('Failed to load hub details:', err);
        });
}

function renderQANavigationWithChildren(hub) {
    const container = document.getElementById('qa-list-nav-container');
    const backButton = document.getElementById('qa-back-button');

    if (!container) return;

    container.innerHTML = '';
    backButton.style.display = 'inline-block';

    // Add option to select the hub itself
    const addHubBtn = document.createElement('button');
    addHubBtn.className = 'qa-nav-item qa-nav-current';
    addHubBtn.dataset.listId = hub.id;
    addHubBtn.innerHTML = `
        <i class="fa-solid fa-folder-tree"></i>
        <span>Add "${escapeHtml(hub.title)}" (This Hub)</span>
    `;
    addHubBtn.onclick = () => selectQAList(hub.id, hub.title);
    container.appendChild(addHubBtn);

    const divider = document.createElement('div');
    divider.className = 'qa-nav-divider';
    divider.textContent = 'Or select a child project:';
    container.appendChild(divider);

    // Show child projects
    const children = hub.items.filter(item => item.linked_list_id);

    if (children.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'qa-nav-empty';
        empty.textContent = 'This hub has no child projects.';
        container.appendChild(empty);
        return;
    }

    children.forEach(item => {
        const childList = qaNavState.allLists.find(l => l.id === item.linked_list_id);
        if (!childList) return;

        const navItem = document.createElement('button');
        navItem.className = 'qa-nav-item';
        navItem.dataset.listId = childList.id;

        const icon = childList.type === 'hub'
            ? '<i class="fa-solid fa-folder-tree"></i>'
            : '<i class="fa-solid fa-list-check"></i>';

        const arrow = childList.type === 'hub'
            ? '<i class="fa-solid fa-chevron-right"></i>'
            : '';

        navItem.innerHTML = `
            ${icon}
            <span>${escapeHtml(childList.title)}</span>
            ${arrow}
        `;

        if (childList.type === 'hub') {
            navItem.onclick = () => navigateIntoHub(childList.id);
        } else {
            navItem.onclick = () => selectQAList(childList.id, childList.title);
        }

        container.appendChild(navItem);
    });

    highlightSelectedQAList();
}

function qaNavBack() {
    if (qaNavState.stack.length === 0) return;

    const previousParent = qaNavState.stack.pop();
    qaNavState.currentParent = previousParent;

    if (previousParent === null) {
        renderQANavigation();
    } else {
        // Fetch the previous hub's details
        fetch(`/api/lists/${previousParent}`)
            .then(r => r.json())
            .then(hub => {
                renderQANavigationWithChildren(hub);
            })
            .catch(err => {
                console.error('Failed to load hub details:', err);
                renderQANavigation();
            });
    }
}

function selectQAList(listId, listTitle) {
    qaNavState.selectedListId = listId;
    qaNavState.selectedListTitle = listTitle;

    // Update the title field if it's empty
    const titleInput = document.getElementById('qa-title');
    if (titleInput && !titleInput.value.trim()) {
        titleInput.value = listTitle;
    }

    // Visual feedback
    const container = document.getElementById('qa-list-nav-container');
    if (container) {
        const items = container.querySelectorAll('.qa-nav-item');
        items.forEach(item => item.classList.remove('selected'));

        const selectedItem = Array.from(items).find(item =>
            item.textContent.includes(listTitle)
        );
        if (selectedItem) {
            selectedItem.classList.add('selected');
        }
    }
}

function highlightSelectedQAList() {
    if (!qaNavState.selectedListId) return;
    const container = document.getElementById('qa-list-nav-container');
    if (!container) return;
    const items = container.querySelectorAll('.qa-nav-item');
    items.forEach(item => item.classList.remove('selected'));
    const selectedItem = container.querySelector(`[data-list-id="${qaNavState.selectedListId}"]`);
    if (selectedItem) {
        selectedItem.classList.add('selected');
    }
}

async function loadNotesForQuickAccess(selectedNoteId = '') {
    try {
        const response = await fetch('/api/notes?all=1');
        const notes = await response.json();
        const select = document.getElementById('qa-note-select');
        select.innerHTML = '<option value="">-- Select a note --</option>';
        notes.forEach(note => {
            const option = document.createElement('option');
            option.value = note.id;
            option.textContent = note.title;
            select.appendChild(option);
        });
        if (selectedNoteId) {
            select.value = String(selectedNoteId);
        }
    } catch (error) {
        console.error('Failed to load notes:', error);
    }
}

function extractCalendarDate(url) {
    if (!url) return '';
    const match = url.match(/[?&]day=([^&]+)/);
    return match ? decodeURIComponent(match[1]) : '';
}

function openEditQuickAccessModal(id, event) {
    if (event) {
        event.preventDefault();
        event.stopPropagation();
    }
    const item = qaItemsById.get(id);
    if (!item) return;

    qaEditingId = id;
    setQuickAccessModalMode('edit');
    document.getElementById('add-quick-access-modal').classList.add('active');

    document.getElementById('qa-title').value = item.title || '';
    document.getElementById('qa-icon').value = item.icon || 'fa-solid fa-bookmark';
    document.getElementById('qa-type').value = item.item_type || 'custom';
    document.getElementById('qa-url').value = item.url || '';
    document.getElementById('qa-date').value = item.item_type === 'calendar' ? extractCalendarDate(item.url) : '';

    resetQANavState();
    if (item.item_type === 'list' && item.reference_id) {
        qaNavState.selectedListId = item.reference_id;
        qaNavState.selectedListTitle = item.title || '';
        loadListsForQuickAccess(item.reference_id, item.title || '');
    } else {
        loadListsForQuickAccess();
    }

    if (item.item_type === 'note' && item.reference_id) {
        loadNotesForQuickAccess(item.reference_id);
    } else {
        loadNotesForQuickAccess();
    }

    handleQuickAccessTypeChange();
}

async function saveQuickAccessItem() {
    const type = document.getElementById('qa-type').value;
    const title = document.getElementById('qa-title').value.trim();
    const icon = document.getElementById('qa-icon').value.trim();

    if (!title) {
        alert('Please enter a title');
        return;
    }

    let url = '';
    let referenceId = null;

    if (type === 'custom') {
        url = document.getElementById('qa-url').value.trim();
        if (!url) {
            alert('Please enter a URL');
            return;
        }
    } else if (type === 'list') {
        if (!qaNavState.selectedListId) {
            alert('Please select a list');
            return;
        }
        url = `/list/${qaNavState.selectedListId}`;
        referenceId = qaNavState.selectedListId;
    } else if (type === 'note') {
        const noteId = document.getElementById('qa-note-select').value;
        if (!noteId) {
            alert('Please select a note');
            return;
        }
        url = `/notes/${noteId}`;
        referenceId = parseInt(noteId);
    } else if (type === 'calendar') {
        const dateValue = document.getElementById('qa-date').value;
        if (!dateValue) {
            alert('Please select a date');
            return;
        }
        url = `/calendar?day=${dateValue}&mode=day`;
    }

    try {
        const isEdit = !!qaEditingId;
        const endpoint = isEdit ? `/api/quick-access/${qaEditingId}` : '/api/quick-access';
        const method = isEdit ? 'PUT' : 'POST';
        const response = await fetch(endpoint, {
            method: method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                title: title,
                icon: icon,
                url: url,
                item_type: type,
                reference_id: referenceId
            })
        });

        if (response.ok) {
            closeAddQuickAccessModal();
            loadQuickAccessItems();
        } else {
            alert(`Failed to ${isEdit ? 'update' : 'add'} item`);
        }
    } catch (error) {
        console.error('Failed to save quick access item:', error);
        alert('Failed to save item');
    }
}

async function deleteQuickAccessItem(id, event) {
    event.preventDefault();
    event.stopPropagation();

    // Use global confirm modal
    const modal = document.getElementById('confirm-modal');
    const message = document.getElementById('confirm-message');
    const confirmBtn = document.getElementById('confirm-yes-button');

    if (!modal || !message || !confirmBtn) {
        console.error('Confirm modal not found');
        return;
    }

    message.textContent = 'Remove this item from quick access?';
    modal.classList.add('active');

    // Remove any existing listeners and add new one
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

    newConfirmBtn.onclick = async () => {
        modal.classList.remove('active');

        try {
            const response = await fetch(`/api/quick-access/${id}`, {
                method: 'DELETE'
            });

            if (response.ok) {
                const card = document.querySelector(`[data-id="${id}"]`);
                if (card) {
                    card.remove();
                }
            } else {
                alert('Failed to delete item');
            }
        } catch (error) {
            console.error('Failed to delete quick access item:', error);
            alert('Failed to delete item');
        }
    };
}

function closeConfirmModal() {
    const modal = document.getElementById('confirm-modal');
    if (modal) {
        modal.classList.remove('active');
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

let qaDragState = {
    draggingEl: null,
    dragMoved: false,
    orderChanged: false
};

let qaTouchState = {
    active: false,
    card: null,
    clone: null,
    offsetX: 0,
    offsetY: 0
};

let qaEditMode = {
    active: false,
    longPressTimer: null,
    longPressTriggered: false,
    touchStart: null,
    currentDragCard: null
};

function initQuickAccessEditMode() {
    const grid = document.getElementById('quick-access-grid');
    if (!grid) return;

    const cards = Array.from(grid.querySelectorAll('.quick-access-card:not(.system-item)'));
    cards.forEach(card => {
        card.classList.add('qa-draggable');
        card.removeAttribute('draggable');
        card.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        if (card.dataset.qaInit !== 'true') {
            card.dataset.qaInit = 'true';
            // Desktop events
            card.addEventListener('click', preventQuickAccessNavigation, true);
            card.addEventListener('mousedown', handleQuickAccessMouseDown);
            card.addEventListener('mouseup', handleQuickAccessMouseUp);
            card.addEventListener('mouseleave', handleQuickAccessMouseUp);
            card.addEventListener('dragstart', handleQuickAccessDragStart);
            card.addEventListener('dragend', handleQuickAccessDragEnd);
            card.addEventListener('dragover', handleQuickAccessDragOver);
            card.addEventListener('drop', handleQuickAccessDrop);

            // Mobile touch events - unified handler
            card.addEventListener('touchstart', handleQuickAccessTouchStart, { passive: false });
            card.addEventListener('touchmove', handleQuickAccessTouchMove, { passive: false });
            card.addEventListener('touchend', handleQuickAccessTouchEnd);
            card.addEventListener('touchcancel', handleQuickAccessTouchEnd);
        }
    });

    const doneBtn = document.getElementById('quick-access-done-btn');
    if (doneBtn && !doneBtn.dataset.qaInit) {
        doneBtn.dataset.qaInit = 'true';
        doneBtn.addEventListener('click', exitQuickAccessEditMode);
    }

    // Global click handler to exit edit mode when clicking outside
    if (!grid.dataset.qaGlobalInit) {
        grid.dataset.qaGlobalInit = 'true';

        // Grid-level dragover for handling drops in empty areas
        grid.addEventListener('dragover', (e) => {
            if (!qaEditMode.active || !qaEditMode.currentDragCard) return;
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            const draggingCard = qaEditMode.currentDragCard;
            const targetPosition = getQuickAccessInsertPosition(grid, e.clientX, e.clientY, draggingCard);

            if (targetPosition.insertBefore) {
                if (targetPosition.insertBefore !== draggingCard &&
                    targetPosition.insertBefore !== draggingCard.nextElementSibling) {
                    grid.insertBefore(draggingCard, targetPosition.insertBefore);
                    qaDragState.dragMoved = true;
                }
            } else if (targetPosition.append) {
                const lastChild = grid.lastElementChild;
                if (lastChild !== draggingCard) {
                    grid.appendChild(draggingCard);
                    qaDragState.dragMoved = true;
                }
            }
        });

        document.addEventListener('click', (e) => {
            if (!qaEditMode.active) return;
            if (e.target.closest('.quick-access-card')) return;
            if (e.target.closest('#quick-access-done-btn')) return;
            if (e.target.closest('#add-quick-access-modal')) return;
            if (e.target.closest('.modal')) return;
            exitQuickAccessEditMode();
        });
    }
}

function enterQuickAccessEditMode() {
    if (qaEditMode.active) return;
    qaEditMode.active = true;
    qaDragState.orderChanged = false;

    const grid = document.getElementById('quick-access-grid');
    const doneBtn = document.getElementById('quick-access-done-btn');
    if (grid) {
        grid.classList.add('edit-mode');
        grid.querySelectorAll('.quick-access-card.qa-draggable').forEach(card => {
            card.setAttribute('draggable', 'true');
            card.classList.add('wiggle');
        });
    }
    if (doneBtn) {
        doneBtn.style.display = 'inline-flex';
    }
}

function exitQuickAccessEditMode() {
    if (!qaEditMode.active) return;
    qaEditMode.active = false;

    const grid = document.getElementById('quick-access-grid');
    const doneBtn = document.getElementById('quick-access-done-btn');
    if (grid) {
        grid.classList.remove('edit-mode');
        grid.querySelectorAll('.quick-access-card.qa-draggable').forEach(card => {
            card.removeAttribute('draggable');
            card.classList.remove('dragging');
            card.classList.remove('wiggle');
            card.style.opacity = '';
        });
    }
    if (doneBtn) {
        doneBtn.style.display = 'none';
    }

    // Clean up any leftover clones
    document.querySelectorAll('.touch-drag-clone').forEach(el => el.remove());

    // Save order if changed
    if (qaDragState.orderChanged) {
        saveQuickAccessOrder();
    }

    qaDragState.draggingEl = null;
    qaDragState.dragMoved = false;
    qaDragState.orderChanged = false;
    qaEditMode.currentDragCard = null;
    qaTouchState.active = false;
    qaTouchState.card = null;
    qaTouchState.clone = null;
}

async function saveQuickAccessOrder() {
    const grid = document.getElementById('quick-access-grid');
    if (!grid) return;
    const orderedIds = Array.from(grid.querySelectorAll('.quick-access-card.qa-draggable'))
        .map(card => card.dataset.id)
        .filter(Boolean);
    if (!orderedIds.length) return;

    try {
        await fetch('/api/quick-access/order', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ order: orderedIds })
        });
    } catch (error) {
        console.error('Failed to save quick access order:', error);
    }
}

function preventQuickAccessNavigation(e) {
    if (qaEditMode.active || qaDragState.dragMoved || qaTouchState.active) {
        e.preventDefault();
        e.stopPropagation();
    }
}

// Desktop drag-and-drop handlers
function handleQuickAccessDragStart(e) {
    if (!qaEditMode.active) {
        e.preventDefault();
        return;
    }
    qaEditMode.currentDragCard = e.currentTarget;
    e.currentTarget.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', e.currentTarget.dataset.id || '');

    // Use a timeout to allow the drag image to be created
    setTimeout(() => {
        if (qaEditMode.currentDragCard) {
            qaEditMode.currentDragCard.style.opacity = '0.4';
        }
    }, 0);
}

function handleQuickAccessDragEnd(e) {
    if (qaEditMode.currentDragCard) {
        qaEditMode.currentDragCard.classList.remove('dragging');
        qaEditMode.currentDragCard.style.opacity = '';
        qaEditMode.currentDragCard = null;
    }
    if (qaDragState.dragMoved) {
        qaDragState.orderChanged = true;
        saveQuickAccessOrder();
    }
    setTimeout(() => { qaDragState.dragMoved = false; }, 50);
}

function handleQuickAccessDragOver(e) {
    if (!qaEditMode.active || !qaEditMode.currentDragCard) return;
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';

    const grid = document.getElementById('quick-access-grid');
    const draggingCard = qaEditMode.currentDragCard;
    const targetPosition = getQuickAccessInsertPosition(grid, e.clientX, e.clientY, draggingCard);

    if (targetPosition.insertBefore) {
        if (targetPosition.insertBefore !== draggingCard &&
            targetPosition.insertBefore !== draggingCard.nextElementSibling) {
            grid.insertBefore(draggingCard, targetPosition.insertBefore);
            qaDragState.dragMoved = true;
        }
    } else if (targetPosition.append) {
        const lastChild = grid.lastElementChild;
        if (lastChild !== draggingCard) {
            grid.appendChild(draggingCard);
            qaDragState.dragMoved = true;
        }
    }
}

function handleQuickAccessDrop(e) {
    e.preventDefault();
}

// Get the correct insert position, ensuring we never place before system items
function getQuickAccessInsertPosition(container, x, y, excludeCard) {
    const grid = container;
    const systemItems = [...grid.querySelectorAll('.quick-access-card.system-item')];
    const draggableCards = [...grid.querySelectorAll('.quick-access-card.qa-draggable')]
        .filter(card => card !== excludeCard);

    // Find the last system item to ensure we never insert before it
    const lastSystemItem = systemItems.length > 0 ? systemItems[systemItems.length - 1] : null;

    // Find where to insert based on position
    let insertBefore = null;

    for (const card of draggableCards) {
        const rect = card.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        // Check if the cursor is in the row above this card
        if (y < rect.top) {
            insertBefore = card;
            break;
        }

        // Check if cursor is on the same row (within vertical bounds)
        if (y >= rect.top && y <= rect.bottom) {
            if (x < centerX) {
                insertBefore = card;
                break;
            }
        }
    }

    // If insertBefore is null, append to end
    if (!insertBefore) {
        return { append: true };
    }

    // Make sure we don't insert before system items
    if (lastSystemItem) {
        const systemRect = lastSystemItem.getBoundingClientRect();
        const insertRect = insertBefore.getBoundingClientRect();

        // If the target position is before or at the system item row, insert after system items
        if (insertRect.top <= systemRect.bottom && insertRect.left <= systemRect.right) {
            // Find the first draggable card after system items
            const firstDraggable = grid.querySelector('.quick-access-card.qa-draggable');
            if (firstDraggable && firstDraggable !== excludeCard) {
                return { insertBefore: firstDraggable };
            }
            return { append: true };
        }
    }

    return { insertBefore };
}

// Mobile touch handlers - unified approach
function handleQuickAccessTouchStart(e) {
    if (!e.touches || e.touches.length !== 1) return;

    const card = e.currentTarget;
    const touch = e.touches[0];

    qaEditMode.touchStart = { x: touch.clientX, y: touch.clientY };
    qaEditMode.longPressTriggered = false;

    // Clear any existing timer
    if (qaEditMode.longPressTimer) {
        clearTimeout(qaEditMode.longPressTimer);
    }

    if (qaEditMode.active) {
        // Already in edit mode - start drag immediately
        e.preventDefault();
        startQuickAccessTouchDrag(card, touch.clientX, touch.clientY);
    } else {
        // Not in edit mode - wait for long press
        qaEditMode.longPressTimer = setTimeout(() => {
            qaEditMode.longPressTimer = null;
            qaEditMode.longPressTriggered = true;

            // Enter edit mode
            enterQuickAccessEditMode();

            // Start dragging this card
            startQuickAccessTouchDrag(card, touch.clientX, touch.clientY);
        }, 600); // 600ms long press
    }
}

function handleQuickAccessTouchMove(e) {
    if (!e.touches || e.touches.length !== 1) return;

    const touch = e.touches[0];

    // If we're actively dragging
    if (qaTouchState.active && qaTouchState.clone) {
        e.preventDefault();

        // Move the clone
        const targetX = touch.clientX - qaTouchState.offsetX;
        const targetY = touch.clientY - qaTouchState.offsetY;
        qaTouchState.clone.style.transform = `translate3d(${targetX}px, ${targetY}px, 0)`;

        // Find what card we're over and reorder
        const grid = document.getElementById('quick-access-grid');
        const targetPosition = getQuickAccessInsertPosition(grid, touch.clientX, touch.clientY, qaTouchState.card);

        if (targetPosition.insertBefore) {
            if (targetPosition.insertBefore !== qaTouchState.card &&
                targetPosition.insertBefore !== qaTouchState.card.nextElementSibling) {
                grid.insertBefore(qaTouchState.card, targetPosition.insertBefore);
                qaDragState.orderChanged = true;
            }
        } else if (targetPosition.append) {
            const lastChild = grid.lastElementChild;
            if (lastChild !== qaTouchState.card) {
                grid.appendChild(qaTouchState.card);
                qaDragState.orderChanged = true;
            }
        }
        return;
    }

    // Not dragging yet - check if we should cancel long press
    if (qaEditMode.longPressTimer && qaEditMode.touchStart) {
        const dx = Math.abs(touch.clientX - qaEditMode.touchStart.x);
        const dy = Math.abs(touch.clientY - qaEditMode.touchStart.y);

        if (dx > 10 || dy > 10) {
            clearTimeout(qaEditMode.longPressTimer);
            qaEditMode.longPressTimer = null;
        }
    }
}

function handleQuickAccessTouchEnd(e) {
    // Clear long press timer
    if (qaEditMode.longPressTimer) {
        clearTimeout(qaEditMode.longPressTimer);
        qaEditMode.longPressTimer = null;
    }

    // End drag if active
    if (qaTouchState.active) {
        e.preventDefault();
        endQuickAccessTouchDrag();
        return;
    }

    // Prevent navigation if long press was triggered
    if (qaEditMode.longPressTriggered) {
        e.preventDefault();
        qaEditMode.longPressTriggered = false;
    }
}

function startQuickAccessTouchDrag(card, touchX, touchY) {
    if (qaTouchState.active) return; // Already dragging

    const rect = card.getBoundingClientRect();

    // Create clone for dragging visual
    const clone = card.cloneNode(true);
    clone.classList.add('touch-drag-clone');
    clone.classList.remove('wiggle');
    clone.style.width = `${rect.width}px`;
    clone.style.height = `${rect.height}px`;

    qaTouchState.active = true;
    qaTouchState.card = card;
    qaTouchState.clone = clone;
    qaTouchState.offsetX = touchX - rect.left;
    qaTouchState.offsetY = touchY - rect.top;

    // Style the original card
    card.classList.add('dragging');
    card.style.opacity = '0.3';

    // Position and add clone
    document.body.appendChild(clone);
    const startX = touchX - qaTouchState.offsetX;
    const startY = touchY - qaTouchState.offsetY;
    clone.style.transform = `translate3d(${startX}px, ${startY}px, 0)`;
}

function endQuickAccessTouchDrag() {
    // Remove clone
    if (qaTouchState.clone) {
        qaTouchState.clone.remove();
    }

    // Restore original card
    if (qaTouchState.card) {
        qaTouchState.card.classList.remove('dragging');
        qaTouchState.card.style.opacity = '';
    }

    // Save order if changed
    if (qaDragState.orderChanged) {
        saveQuickAccessOrder();
    }

    // Reset state
    qaTouchState = {
        active: false,
        card: null,
        clone: null,
        offsetX: 0,
        offsetY: 0
    };
    qaDragState.orderChanged = false;
}

// Desktop mouse long-press handlers
function handleQuickAccessMouseDown(e) {
    // Don't trigger on edit/delete buttons
    if (e.target.closest('.quick-access-edit') || e.target.closest('.quick-access-delete')) {
        return;
    }

    if (qaEditMode.active) return;

    qaEditMode.longPressTriggered = false;
    qaEditMode.longPressTimer = setTimeout(() => {
        qaEditMode.longPressTimer = null;
        qaEditMode.longPressTriggered = true;
        enterQuickAccessEditMode();
    }, 600);
}

function handleQuickAccessMouseUp() {
    if (qaEditMode.longPressTimer) {
        clearTimeout(qaEditMode.longPressTimer);
        qaEditMode.longPressTimer = null;
    }
}

// Go to today's calendar in day view
function goToToday(event) {
    event.preventDefault();
    const today = new Date();

    // Get local date components (respects user's timezone)
    const year = today.getFullYear();
    const month = String(today.getMonth() + 1).padStart(2, '0');
    const day = String(today.getDate()).padStart(2, '0');
    const todayStr = `${year}-${month}-${day}`;

    window.location.href = `/calendar?day=${todayStr}&mode=day`;
}

// Go to tomorrow's calendar in day view
function goToTomorrow(event) {
    event.preventDefault();
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);

    // Get local date components (respects user's timezone)
    const year = tomorrow.getFullYear();
    const month = String(tomorrow.getMonth() + 1).padStart(2, '0');
    const day = String(tomorrow.getDate()).padStart(2, '0');
    const tomorrowStr = `${year}-${month}-${day}`;

    window.location.href = `/calendar?day=${tomorrowStr}&mode=day`;
}

// Load items on page load
document.addEventListener('DOMContentLoaded', loadQuickAccessItems);
</script>
{% endblock %}
